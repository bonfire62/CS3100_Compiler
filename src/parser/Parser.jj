/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  // If you are using a different version of Java, change this.
  JDK_VERSION = "1.8";
  static = false;
}

/**
 * This defines the main class that is generated by the parser generator.  We've
 * added a main method to the code that will be generated.
**/
PARSER_BEGIN(Parser)
package parser;

public class Parser
{
  public static void main(String args [])
  {
    Parser parser = new Parser(System.in);
    try
    {
      parser.program();
    }
    catch (ParseException e)
    {
      System.err.println("Parse error: " + e.getMessage());
    }
    catch (TokenMgrError e)
    {
      System.err.println(e.getMessage());
    }
    catch (RuntimeException e)
    {
      System.err.println(e.getMessage());
    }
  }
}
PARSER_END(Parser)

/************************ Regular expressions that define tokens ***********************/
SKIP : /* Whitespace to be ignored */
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN : /* Operators */
{
  < EQUALS : "=" >
| < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
}

TOKEN : /* Keywords and punctuation */
{
  < INTTYPE : "int" >
| < STRINGTYPE : "string" >
| < PRINT : "print" >
| < READ : "read" >
| < SEMI : ";" >
| < LPAREN : "(" >
| < RPAREN : ")" >
| < BOOLTYPE : "boolean" >
| < BOOL : "true" | "false" >
}

TOKEN : /* Constants, variables, strings */
{
  < CONSTANT : (< DIGIT >)+ >
| < NEWLINE : "newline" >
| < #DIGIT : [ "0"-"9" ] >
| < VAR : (< LETTER >)+ >
| < #LETTER :
    [ "a"-"z" ]
  | [ "A"-"Z" ] >
| < STRING : "\"" (~[ "\"", "[", "]" ])* "\"" >
}

/***************************** Productions that define grammar *******************/
void program() :
{
}
{
  (
    statement()
  )*
  < EOF >
}

void statement() :
{
  Token t;
  Token vtype;
  String etype;
}
{
  
  t = < VAR > < EQUALS > etype = exp() < SEMI >
  {
    if (types.get(t.image) == null)
    {
      throw new TypeException("Undeclared variable: " + t.image);
    }
    if (!types.get(t.image).equals(etype))
    {
      throw new TypeException("Type mismatch");
    }		
    char reg = variables.get(t.image);
    System.out.print("s" + reg + " ");
  }
|
  (
    vtype = < INTTYPE >
  | vtype = < STRINGTYPE >
  | vtype = < BOOLTYPE > 
  )
  t = < VAR > < EQUALS > etype = exp() < SEMI >
  {
    if (types.get(t.image) == null)
    {
      if (variables.size() >= 26)
      {
        throw new TypeException("Too many variables; limit is 26");
      }
      variables.put(t.image, (char) ('A' + variables.size()));
      types.put(t.image, vtype.image);
      if (!vtype.image.equals(etype))
      {
        throw new TypeException("Type mismatch");
      }
      char reg2 = variables.get(t.image);
      System.out.print("s" + reg2 + " ");
    }
    else
    {
      throw new TypeException("Variable already declared: " + t.image);
    }
  }
| 
  < PRINT > exp() < SEMI >
  {
    System.out.print("n ");
  }
//|
//
//(vtype = < BOOLTYPE >)
// t = < VAR > < EQUALS > etype = exp() < SEMI >
//
//	{
//	if(etype.equals("boolean"))
//	{
//		variables.put(t.image, (char) ('A' + variables.size()));
//		types.put(t.image, vtype.image);
//		if(!vtype.image.equals(etype))
//		{
//		throw new TypeException("Type mismatch");
//		}
//		
//		
//	}
//	else
//	{
//	throw new TypeException("Type mismatch");
//	}
//}
| 
	< NEWLINE >  < SEMI >
  {
    System.out.print("[] p");
  }
  
//|

//	t = < READ > < VAR > etype = exp() <SEMI>
//	{
//	  //TODO add checking for the variable already being entered, then assign to a register.
//	  System.out.print("?");
//	  variables.put(t.image, (char) ('A' + variables.size()));
//      char reg2 = variables.get(t.image);
//      System.out.print("s" + reg2 + " ");
//	  	
//	}
//  
}
