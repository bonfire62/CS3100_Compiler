/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */
options
{
  // If you are using a different version of Java, change this.
  JDK_VERSION = "1.8";
  static = false;
}

/**
 * This defines the main class that is generated by the parser generator.  We've
 * added a main method to the code that will be generated.
**/
PARSER_BEGIN(Parser)
package parser;

public class Parser
{
  public static void main(String args [])
  {
    Parser parser = new Parser(System.in);
    try
    {
      parser.program();
    }
    catch (ParseException e)
    {
      System.err.println("Parse error: " + e.getMessage());
    }
    catch (TokenMgrError e)
    {
      System.err.println(e.getMessage());
    }
    catch (RuntimeException e)
    {
      System.err.println(e.getMessage());
    }
  }
}
PARSER_END(Parser)

/************************ Regular expressions that define tokens ***********************/
SKIP : /* Whitespace to be ignored */
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN : /* Operators */
{
  < EQUALS : "=" >
| < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
}

TOKEN : /* Keywords and punctuation */
{
  < INTTYPE : "int" >
| < STRINGTYPE : "string" >
| < PRINT : "print" >
| < READ : "read" >
| < SEMI : ";" >
| < LPAREN : "(" >
| < RPAREN : ")" >
| < BOOLTYPE : "boolean" >
| < BOOL : "true" | "false" >
}

TOKEN : /* Constants, variables, strings */
{
  < CONSTANT : (< DIGIT >)+ >
| < NEWLINE : "newline" >
| < #DIGIT : [ "0"-"9" ] >
| < VAR : (< LETTER >)+ >
| < #LETTER :
    [ "a"-"z" ]
  | [ "A"-"Z" ] >
| < STRING : "\"" (~[ "\"", "[", "]" ])* "\"" >
}

/***************************** Productions that define grammar *******************/
void program() :
{
}
{
  ( statement() )* < EOF >
}

void statement() :
{
}
{
  < VAR > < EQUALS > exp() < SEMI >
|
  ( < INTTYPE > | < STRINGTYPE > | < BOOLTYPE >) < VAR > < EQUALS > exp() < SEMI >
|   
  < PRINT > exp() < SEMI >
}

void exp() :
{
}
{
  term()
  (
    ( < PLUS > | < MINUS > ) term()
  )*
}

 void term() :
{
}
{
  factor()
  (
    ( < MULTIPLY > | < DIVIDE > ) factor()
  )*
}

void factor() :
{
}
{
  < MINUS > element()
|
  element()
}

void element() :
{
}
{
  < CONSTANT >
|
  < STRING >
|  
  < VAR >
|
  < LPAREN > exp() < RPAREN >
|
  < BOOLTYPE > 
}
