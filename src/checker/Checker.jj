/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{
  // If you are using a different version of Java, change this.  JDK_VERSION = "1.8";  static = false;}/**
 * This defines the main class that is generated by the parser generator.  We've
 * added a main method to the code that will be generated.
**/PARSER_BEGIN(Checker)package checker;import java.util.HashMap;
public class Checker{
  // Maps programming language variables to types.
  private HashMap<String, String > types =
        new HashMap<String, String >();

  // If the type is not "int", throws a TypeException
  public void checkInt (String type)
  {    if (!(type.equals("int")))
    {      throw new TypeException("Expected int, received " + type);
    }
  }
    public static void main(String args [])  {    Checker checker = new Checker(System.in);    try    {      checker.program();    }
    catch (TypeException e)
    {      System.err.println("Type error: " + e.getMessage());
    }    catch (ParseException e)    {      System.err.println("Parse error: " + e.getMessage());    }    catch (TokenMgrError e)    {      System.err.println(e.getMessage());    }
    catch (RuntimeException e)
    {
      System.err.println(e.getMessage());
    }  }}

/**
 * Exception used to report type-checking errors.
 */
 class TypeException extends RuntimeException
 {   public TypeException (String message)
   {     super(message);
   }
 }PARSER_END(Checker)/************************ Regular expressions that define tokens ***********************/SKIP : /* Whitespace to be ignored */
{
  " "
| "\r"
| "\t"
| "\n"
}

TOKEN : /* Operators */
{
  < EQUALS : "=" >
| < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
}

TOKEN : /* Keywords and punctuation */
{
  < INTTYPE : "int" >
| < STRINGTYPE : "string" >
| < PRINT : "print" >
| < SEMI: ";" >
| < LPAREN: "(" >
| < RPAREN: ")" >
}

TOKEN : /* Constants, variables, strings */
{
  < CONSTANT : (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ] >
| < VAR : (< LETTER >)+ >
| < #LETTER : [ "a"-"z" ] | [ "A"-"Z" ] >
| < STRING: "\"" (~["\"", "[", "]"])* "\"" >
}
/***************************** Productions that define grammar *******************/void program() :{
}{  ( statement() )* < EOF >}
void statement() :{  Token t;
  Token vtype;
  String etype;}{    t = < VAR > < EQUALS > etype = exp() < SEMI >    {      if (types.get(t.image) == null)      {          throw new TypeException("Undeclared variable: " + t.image);      }
      if (!types.get(t.image).equals(etype))
	  {
		  throw new TypeException("Type mismatch");
      }    }   |
    (vtype = < INTTYPE > | vtype = < STRINGTYPE >) t = < VAR > < EQUALS > etype = exp() < SEMI >
    {
      if (types.get(t.image) == null)
      {
		types.put(t.image, vtype.image);

		if (!vtype.image.equals(etype))
		{		  throw new TypeException("Type mismatch");
		}
      }
      else
      {        throw new TypeException("Variable already declared: " + t.image);
      }
    }
|       < PRINT > exp() < SEMI >}String exp() :{  Token t;
  String type1, type2;}{  type1 = term()  (    ( t = < PLUS > | t = < MINUS > ) type2 = term()    {
      checkInt(type1);
	  checkInt(type2);
    }  )*
  {    return type1;
  }}String term() :{  Token t;
  String type1, type2;}{  type1 = factor()  (    ( t = < MULTIPLY > | t = < DIVIDE > ) type2 = factor()    {
      checkInt(type1);
      checkInt(type2);    }  )*
  {
    return type1;  }}String factor() :{
  String type;
}{  < MINUS > type = element()
  {
    checkInt(type);
    return "int";  }|
  type = element()
  {	return type;
  }}String element() :{  Token t;
  String type;}{  < CONSTANT >  {
    return "int";  }
|
  < STRING >
  {
	return "string";
  }
|    t = < VAR >  {
    if (types.get(t.image) == null)
    {		throw new TypeException("Undefined variable " + t.image);
    }
    return types.get(t.image);  }
|
  < LPAREN > type = exp() < RPAREN >
  {	return type;
  }}
